##黑马苍穹外卖仿写
————2024.2.29

---
###日志
###### 2.29 阅读已有代码以及数据库表的关系

首先在application-dev中修改连接数据库的用户名密码

其使用了一个配置文件"分割"【多环境配置】


###### 3.1

IDEA的TODO使用、已有代码进行基础了解，数据库表过于抽象

Swagger基本了解 简单密码比对加密


###### 3.2

Swagger 注解了解【只有pojo之中有依赖包】，解决请求头无令牌问题【全局配置中可进行添加】

###### 新增员工：传入数据前端、数据库都进行值的验证，前端传递的值DTO与后端存储的表对象Entry进行分离，
其中有大量相同属性【一样命名】使用BeanUtils进行克隆值，其余就是常量及时间， 还有两个获取的id【以下方法】

问题：
1、获取的id：JWT令牌的荷载读取，引入新技术JDK中的ThreadLocal，可进行**单一线程的值共享**，common中context进行封装

2、用户名唯一问题：通过全局异常处理器处理【异常处理器均为重载】，对异常进行分析，是否为SQL用户名唯一异常，优点：**完善了未知异常【非自定义】的处理**
2.5【大概?】、在新增用户之前进行一次用户名查询【已有SQL】，有异常将其进行抛出，优点：增加了自定义的异常处理面

###### 员工分页查询：经典的分页插件加条件查询【动态SQL:where、if】，Swagger返回值没依赖无法进行参数说明【可自行添加】
讲解分页插件的底层也使用了ThreadLocal进行初始配置时的传值

问题：
1、返回中时间为数组格式：
两种做法，

第一种，在**真实返回值内部属性**中添加@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")进行格式转换

第二种，进行消息转换器【已进行封装【按固定格式来记】】的添加【包含特异性，但只需配置一次】，做法：
配置类添加方法【按固定格式来记】，创建消息转换器容器然后添加自己的消息转换器，并且设置索引【广义优先级】


###### 3.3 分页查询问题解决
###### 员工禁用与启用：经典根据id进行修改，扩大其SQL语句的复用性，使用动态SQL进行全属性的判断以及顺便的des排序

lombok新注解@Builder 可进行静态链式创建，头.builder()、中部直接给值非set()、尾.build();

###### 编辑员工:1.分为两步 id查询进行回显、2.修改数据进行存储

1、根据id进行查找【查询其返回响应不需要泛形】，路径参数，传入id，进行查询
【对表进行查询，其返回时一定是表的Entry对象】，可以在业务层对其进行隐藏部分属性

【此处，我将其转化为DTO对象】【但是无伤大雅,也等于变相的进行了数据的隐藏

【**错误做法**，DTO是前端传入对象，传递给前端的应当是Entry或者VO对象【有些响应对象比表值更多比如:DishVO】】

2、修改数据进行存储，【接口文档中Headers-参数值-json格式要添加@RequestBody】，传入为DTO，业务层中对表进行修改为Entry
【并且添加修改时间与修改人id】进行之前禁用写的扩展SQL语句

添加了关于菜品分类模块的3层次代码实现了如下接口
- 新增分类
- 分类分页查询
- 根据id删除分类
- 修改分类
- 启用禁用分类
- 根据类型查询分类


###### 3.4
###### 进行公共字段填充：完善了禁用启用无修改的问题

使用AOP切面类对Mapper进行【因为其传入参数必定包含Entry的实体

复习AOP，使用自定义注解，新的连接点方法，通过反射进行填充公共字段填充

create_time创建时间、create_user创建人、 update_time修改时间、update_user修改人

###### 菜品新增：分为3个
- 根据类型查询分类（已完成）【导入】
- 文件上传【OOS
- 新增菜品【涉及到两个表，但只是其请求包含

文件上传,在5.springBoot原理当中，便进行了一次类似的封装模块。
不同的是对于其配置词的 endpoint 进行了前缀处理，要删除http//,
以及配置文件AliOssProperties已经成为了Bean对象【有依赖，进行了扫描】，
此时使用的配置类OssConfiguration只是降低耦合，
以及使用了@ConditionalOnMissingBean【类似单例模式】，用@Autowired也行

新增菜品，其前端请求DTO文件包含两个表内容，
在业务层中,两个表故要**开启事务进行同生共死**
第1个表插入一条数据
【需要用到主键返回，之前讲过非动态SQL的写法：加注解@Options】，
**此处相当是对其XML形式进行补全。**
第2个表插入多条数据,且其数据未知条数故使用动态SQL
【此前使用过foreach进行多条删除】
此处相当于是对多条插入进行补全，并且得知foreach内部依然可以配置每条的格式。


###### 3.4
#######菜品分页查询:
其响应内容包含多表，**明显的左外连接**【熟悉多表连接】返回data内部使用dishVO
其余均为正常分页查询、动态SQL，if添加and 并且name模糊查询

注意点：第二个表放回的属性要对应响应VO名字才会进行映射故要起别名
【多表查询时要对重复属性添加表前缀】

#######删除菜品:
先观察产品原型得到业务规则
【**表的连接**【相关表有关系，不能删除】加上**真实使用**【在售卖，无法删除】】、
菜品表其子表菜品口味表需要一同删除【根据 id】
同样涉及到多个表**开启事务进行同生共死**

由于是企业级项目，在写SQL语句时，尽量将其扩写并不拘泥于一条语句
select * from dish where id = #{id},不要写成select count(*) from dish where id = #{id} and status = 1【只为查询】

在写中间表SQL语句查询时，select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)
补全了["批量"]:批量删除，批量添加、**批量查询**、【批量查询将多个对应id对象改为相同的赋值属性】

【自我修改】将单个for循环删除改为批量删除，笨比【对于前端来说无所谓


#######修改菜品:
涉及4个接口

**接口：**
- 根据id查询菜品【回显
- 根据类型查询分类(已实现)
- 文件上传(已实现)
- 修改菜品

根据id查询菜品：返回的是VO对象，其内容包含两个表故使用两个查询
【此处不能使用连接表，为什么呢？】【**因为不会自动封装为List<>**】

修改菜品：DTO文件进行分解分为两个进行修改

第一个dish就直接克隆即可
第二个dish_flavor有些有有些没有，干脆直接删除在进行一次添加【刚好也能用到之前写的SQL语句
类似于插入，但是主键为刚写的**回显是包含id**的，【被删除的老的包含，但是新的不包含故还是需要进行遍历set】


###### 3.5 先补全视频查看有无遗漏
牛魔既有单个删除，也有批量删除【这就是不看视频的代价

在修改以及回显中包含多表SQL使用，DishVO甚至包含3个表的内容
其中修改以及回显中都有运用分类表的**类型**查询表

修改口味表选择直接删除再次添加是因为其id并没有相关表的连接【比如分类就不能修改因为其有关联外键



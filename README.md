##黑马苍穹外卖仿写
————2024.2.29

---
###日志
###### 2.29 阅读已有代码以及数据库表的关系

首先在application-dev中修改连接数据库的用户名密码

其使用了一个配置文件"分割"【多环境配置】


### 3.1

IDEA的TODO使用、已有代码进行基础了解，数据库表过于抽象

Swagger基本了解 简单密码比对加密


### 3.2

Swagger 注解了解【只有pojo之中有依赖包】，解决请求头无令牌问题【全局配置中可进行添加】

###### 新增员工：传入数据前端、数据库都进行值的验证，前端传递的值DTO与后端存储的表对象Entry进行分离，
其中有大量相同属性【一样命名】使用BeanUtils进行克隆值，其余就是常量及时间， 还有两个获取的id【以下方法】

问题：
1、获取的id：JWT令牌的荷载读取，引入新技术JDK中的ThreadLocal，可进行**单一线程的值共享**，common中context进行封装

2、用户名唯一问题：通过全局异常处理器处理【异常处理器均为重载】，对异常进行分析，是否为SQL用户名唯一异常，优点：**完善了未知异常【非自定义】的处理**
2.5【大概?】、在新增用户之前进行一次用户名查询【已有SQL】，有异常将其进行抛出，优点：增加了自定义的异常处理面

###### 员工分页查询：经典的分页插件加条件查询【动态SQL:where、if】，Swagger返回值没依赖无法进行参数说明【可自行添加】
讲解分页插件的底层也使用了ThreadLocal进行初始配置时的传值

问题：
1、返回中时间为数组格式：
两种做法，

第一种，在**真实返回值内部属性**中添加@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")进行格式转换

第二种，进行消息转换器【已进行封装【按固定格式来记】】的添加【包含特异性，但只需配置一次】，做法：
配置类添加方法【按固定格式来记】，创建消息转换器容器然后添加自己的消息转换器，并且设置索引【广义优先级】


### 3.3 分页查询问题解决
###### 员工禁用与启用：经典根据id进行修改，扩大其SQL语句的复用性，使用动态SQL进行全属性的判断以及顺便的des排序

lombok新注解@Builder 可进行静态链式创建，头.builder()、中部直接给值非set()、尾.build();

###### 编辑员工:1.分为两步 id查询进行回显、2.修改数据进行存储

1、根据id进行查找【查询其返回响应不需要泛形】，路径参数，传入id，进行查询
【对表进行查询，其返回时一定是表的Entry对象】，可以在业务层对其进行隐藏部分属性

【此处，我将其转化为DTO对象】【但是无伤大雅,也等于变相的进行了数据的隐藏

【**错误做法**，DTO是前端传入对象，传递给前端的应当是Entry或者VO对象【有些响应对象比表值更多比如:DishVO】】

2、修改数据进行存储，【接口文档中Headers-参数值-json格式要添加@RequestBody】，传入为DTO，业务层中对表进行修改为Entry
【并且添加修改时间与修改人id】进行之前禁用写的扩展SQL语句

添加了关于菜品分类模块的3层次代码实现了如下接口
- 新增分类
- 分类分页查询
- 根据id删除分类
- 修改分类
- 启用禁用分类
- 根据类型查询分类


### 3.4
###### 进行公共字段填充：完善了禁用启用无修改的问题

使用AOP切面类对Mapper进行【因为其传入参数必定包含Entry的实体

复习AOP，使用自定义注解，新的连接点方法，通过反射进行填充公共字段填充

create_time创建时间、create_user创建人、 update_time修改时间、update_user修改人

###### 菜品新增：分为3个
- 根据类型查询分类（已完成）【导入】
- 文件上传【OOS
- 新增菜品【涉及到两个表，但只是其请求包含

文件上传,在5.springBoot原理当中，便进行了一次类似的封装模块。
不同的是对于其配置词的 endpoint 进行了前缀处理，要删除http//,
以及配置文件AliOssProperties已经成为了Bean对象【有依赖，进行了扫描】，
此时使用的配置类OssConfiguration只是降低耦合，
以及使用了@ConditionalOnMissingBean【类似单例模式】，用@Autowired也行

新增菜品，其前端请求DTO文件包含两个表内容，
在业务层中,两个表故要**开启事务进行同生共死**
第1个表插入一条数据
【需要用到主键返回，之前讲过非动态SQL的写法：加注解@Options】，
**此处相当是对其XML形式进行补全。**
第2个表插入多条数据,且其数据未知条数故使用动态SQL
【此前使用过foreach进行多条删除】
此处相当于是对多条插入进行补全，并且得知foreach内部依然可以配置每条的格式。


### 3.5
#######菜品分页查询:
其响应内容包含多表，**明显的左外连接**【熟悉多表连接】返回data内部使用dishVO
其余均为正常分页查询、动态SQL，if添加and 并且name模糊查询

注意点：第二个表放回的属性要对应响应VO名字才会进行映射故要起别名
【多表查询时要对重复属性添加表前缀】

#######删除菜品:
先观察产品原型得到业务规则
【**表的连接**【相关表有关系，不能删除】加上**真实使用**【在售卖，无法删除】】、
菜品表其子表菜品口味表需要一同删除【根据 id】
同样涉及到多个表**开启事务进行同生共死**

由于是企业级项目，在写SQL语句时，尽量将其扩写并不拘泥于一条语句
select * from dish where id = #{id},不要写成select count(*) from dish where id = #{id} and status = 1【只为查询】

在写中间表SQL语句查询时，select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)
补全了["批量"]:批量删除，批量添加、**批量查询**、【批量查询将多个对应id对象改为相同的赋值属性】

【自我修改】将单个for循环删除改为批量删除，笨比【对于前端来说无所谓


#######修改菜品:
涉及4个接口

**接口：**
- 根据id查询菜品【回显
- 根据类型查询分类(已实现)
- 文件上传(已实现)
- 修改菜品

根据id查询菜品：返回的是VO对象，其内容包含两个表故使用两个查询
【此处不能使用连接表，为什么呢？】【**因为不会自动封装为List<>**】

修改菜品：DTO文件进行分解分为两个进行修改

第一个dish就直接克隆即可
第二个dish_flavor有些有有些没有，干脆直接删除在进行一次添加【刚好也能用到之前写的SQL语句
类似于插入，但是主键为刚写的**回显是包含id**的，【被删除的老的包含，但是新的不包含故还是需要进行遍历set】


### 3.6 先补全视频查看有无遗漏
牛魔既有单个删除，也有批量删除【这就是不看视频的代价

在修改以及回显中包含多表SQL使用，DishVO甚至包含3个表的内容
其中修改以及回显中都有运用分类表的**类型**查询表

修改口味表选择直接删除再次添加是因为其id并没有相关表的连接【比如分类就不能修改因为其有关联外键

###### 菜品管理，菜品起售停售功能：
类似于启用禁用员工账号【100%一样
大错特错
没有考虑到表和表之间的关系
有一个**中间表菜品套餐表**
`如果菜品与套餐有关联，套餐中的一个菜品进行了停售，那么这个套餐也要进行停售`

###### 修改密码：
要手动地进行当前员工 id 获取【因为使用员工id的地方少，切面类中只对新增以及修改进行了自动填充公共数据
通过 id 进行查询，
然后进行比对，
错误的进行抛出异常，
最后进行修改


###### 新增套餐：
类似于新增菜品【均为插入
其DTO下包含套餐表的修改，以及其连接表同菜品的关系
【同样要进行主键的返回】【但其同菜品的关系是必填的，故不需要进行判断

如何选取其菜品同套餐的关系呢？
【让套餐可通过 `分类表中菜品id` 查询 `对应菜品表中菜品` 选择其中菜品
【==**前置接口+1**==】
根据分类id查询菜品[要对菜品状态进行判断，**在售才可进行显示**【**菜品禁用时，套餐要禁用**


### 3.7 
牛魔，OOS对象密钥泄露，已经禁用【下次记得忽略
上午全在改这个,随便尝试解决德鲁伊报错将版本1.2.1改为1.2.2

目标任务：了解到了接口的更多关系，比如分类接口中的`根据类型查分类`可查询菜品以及套餐列表，也就是`菜品分类`与`套餐分类`【新增右上角】
一个小小的理解了一下

###### 套餐分页查询：
同菜品分页查询类似，有一个参数存在于`分类表`中叫做套餐类型，
需要你将两表进行左外连接进行查询，并且要起别名，让其产生自动映射【多表语句时最好，所有属性都要进行注明
【这个属性同菜品的分类名称一样，是在新建时选用的【使用的是分类表中的`通过类型查询分类`接口】】

###### 删除套餐：
通过业务原型右侧，可得知在售不能进行删除，同菜品删除一样【**需要通过id查询进行判断**
删除时需要删除两个表,
一个是套餐本表，
一个是中间表


### 3.8 写完day4的课后接口

###### 修改套餐
需要有前置
根据 id 查询套餐【回显】【包含回显需要两个表进行融合】
修改：同菜品修改一样，套餐表进行直接修改，套餐菜品表进行**批量删除，
以及批量插入**【新选中的菜品关系是独立的需要自行 set 对应`套餐id`】

###### 起售停售套餐
直接修改即可【在写菜品禁用时已经写好逻辑】
【上的禁用，不会影响到下的禁用】
但是其启用需要对其**连接表内进行查询**后对**菜品表查询全为启用**才可启用
1、【反转 `菜品删除` 中的查询中间表【单个查询怕返回集合 】
2、foreach 遍历进行菜品表的 id 查询进行状态判断【不行则抛出异常】
答案中是使用连接表的方式，确实帅

###### Redis!
学习Redis使用在java中
一、先导入依赖。
二、对其yaml中进行配置。port、host等数据
三、新建配置类加入Bean对象【主要目的：进行自定义的消息序列化】
四、配置的Bean对象进行调用Redis的各种语句进行操作

###### 新增店铺接口：
对营业状态进行查询和修改
【由于其分为用户端以及管理端，其用户端也需要进行查询故对用户端也复制一份】

同上原因，其分为两个端:生成接口文档需要两份对双端进行扫描
【复制代码修改扫描对象并且进行分组即可】



### 3.9 直接day6,开新内容了
byd直接看完了
学习HttpClient相关api，使用封装工具类
介绍微信小程序的开发，导入写好的代码——前端页面

书写C端-根据微信登录流程：
使用封装工具类请求微信获取openid
根据Openid查询用户，老用户则获取id，新用户则插入返回主键获取

新增JWT拦截器用户端：
新增拦截类，配置类中额外注册拦截对象

修正错误，用户创建时修正为用户获取

新增C端-浏览功能4个
`均需要前提-在售`

根据类型查询分类
根据分类 id 查询菜品
根据分类 id 查询套餐
根据套餐 id 查询包含的菜品


### 3.10 速度减缓
上午编写日志以及笔记


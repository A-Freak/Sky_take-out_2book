##黑马苍穹外卖仿写
————2024.2.29

---
###日志
###### 2.29 阅读已有代码以及数据库表的关系

首先在application-dev中修改连接数据库的用户名密码

其使用了一个配置文件"分割"【多环境配置】


### 3.1

IDEA的TODO使用、已有代码进行基础了解，数据库表过于抽象

Swagger基本了解 简单密码比对加密


### 3.2

Swagger 注解了解【只有pojo之中有依赖包】，解决请求头无令牌问题【全局配置中可进行添加】

###### 新增员工：传入数据前端、数据库都进行值的验证，前端传递的值DTO与后端存储的表对象Entry进行分离，
其中有大量相同属性【一样命名】使用BeanUtils进行克隆值，其余就是常量及时间， 还有两个获取的id【以下方法】

问题：
1、获取的id：JWT令牌的荷载读取，引入新技术JDK中的ThreadLocal，可进行**单一线程的值共享**，common中context进行封装

2、用户名唯一问题：通过全局异常处理器处理【异常处理器均为重载】，对异常进行分析，是否为SQL用户名唯一异常，优点：**完善了未知异常【非自定义】的处理**
2.5【大概?】、在新增用户之前进行一次用户名查询【已有SQL】，有异常将其进行抛出，优点：增加了自定义的异常处理面

###### 员工分页查询：经典的分页插件加条件查询【动态SQL:where、if】，Swagger返回值没依赖无法进行参数说明【可自行添加】
讲解分页插件的底层也使用了ThreadLocal进行初始配置时的传值

问题：
1、返回中时间为数组格式：
两种做法，

第一种，在**真实返回值内部属性**中添加@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")进行格式转换

第二种，进行消息转换器【已进行封装【按固定格式来记】】的添加【包含特异性，但只需配置一次】，做法：
配置类添加方法【按固定格式来记】，创建消息转换器容器然后添加自己的消息转换器，并且设置索引【广义优先级】


### 3.3 分页查询问题解决
###### 员工禁用与启用：经典根据id进行修改，扩大其SQL语句的复用性，使用动态SQL进行全属性的判断以及顺便的des排序

lombok新注解@Builder 可进行静态链式创建，头.builder()、中部直接给值非set()、尾.build();

###### 编辑员工:1.分为两步 id查询进行回显、2.修改数据进行存储

1、根据id进行查找【查询其返回响应不需要泛形】，路径参数，传入id，进行查询
【对表进行查询，其返回时一定是表的Entry对象】，可以在业务层对其进行隐藏部分属性

【此处，我将其转化为DTO对象】【但是无伤大雅,也等于变相的进行了数据的隐藏

【**错误做法**，DTO是前端传入对象，传递给前端的应当是Entry或者VO对象【有些响应对象比表值更多比如:DishVO】】

2、修改数据进行存储，【接口文档中Headers-参数值-json格式要添加@RequestBody】，传入为DTO，业务层中对表进行修改为Entry
【并且添加修改时间与修改人id】进行之前禁用写的扩展SQL语句

添加了关于菜品分类模块的3层次代码实现了如下接口
- 新增分类
- 分类分页查询
- 根据id删除分类
- 修改分类
- 启用禁用分类
- 根据类型查询分类


### 3.4
###### 进行公共字段填充：完善了禁用启用无修改的问题

使用AOP切面类对Mapper进行【因为其传入参数必定包含Entry的实体

复习AOP，使用自定义注解，新的连接点方法，通过反射进行填充公共字段填充

create_time创建时间、create_user创建人、 update_time修改时间、update_user修改人

###### 菜品新增：分为3个
- 根据类型查询分类（已完成）【导入】
- 文件上传【OOS
- 新增菜品【涉及到两个表，但只是其请求包含

文件上传,在5.springBoot原理当中，便进行了一次类似的封装模块。
不同的是对于其配置词的 endpoint 进行了前缀处理，要删除http//,
以及配置文件AliOssProperties已经成为了Bean对象【有依赖，进行了扫描】，
此时使用的配置类OssConfiguration只是降低耦合，
以及使用了@ConditionalOnMissingBean【类似单例模式】，用@Autowired也行

新增菜品，其前端请求DTO文件包含两个表内容，
在业务层中,两个表故要**开启事务进行同生共死**
第1个表插入一条数据
【需要用到主键返回，之前讲过非动态SQL的写法：加注解@Options】，
**此处相当是对其XML形式进行补全。**
第2个表插入多条数据,且其数据未知条数故使用动态SQL
【此前使用过foreach进行多条删除】
此处相当于是对多条插入进行补全，并且得知foreach内部依然可以配置每条的格式。


### 3.5
#######菜品分页查询:
其响应内容包含多表，**明显的左外连接**【熟悉多表连接】返回data内部使用dishVO
其余均为正常分页查询、动态SQL，if添加and 并且name模糊查询

注意点：第二个表放回的属性要对应响应VO名字才会进行映射故要起别名
【多表查询时要对重复属性添加表前缀】

#######删除菜品:
先观察产品原型得到业务规则
【**表的连接**【相关表有关系，不能删除】加上**真实使用**【在售卖，无法删除】】、
菜品表其子表菜品口味表需要一同删除【根据 id】
同样涉及到多个表**开启事务进行同生共死**

由于是企业级项目，在写SQL语句时，尽量将其扩写并不拘泥于一条语句
select * from dish where id = #{id},不要写成select count(*) from dish where id = #{id} and status = 1【只为查询】

在写中间表SQL语句查询时，select setmeal_id from setmeal_dish where dish_id in (1,2,3,4)
补全了["批量"]:批量删除，批量添加、**批量查询**、【批量查询将多个对应id对象改为相同的赋值属性】

【自我修改】将单个for循环删除改为批量删除，笨比【对于前端来说无所谓


#######修改菜品:
涉及4个接口

**接口：**
- 根据id查询菜品【回显
- 根据类型查询分类(已实现)
- 文件上传(已实现)
- 修改菜品

根据id查询菜品：返回的是VO对象，其内容包含两个表故使用两个查询
【此处不能使用连接表，为什么呢？】【**因为不会自动封装为List<>**】

修改菜品：DTO文件进行分解分为两个进行修改

第一个dish就直接克隆即可
第二个dish_flavor有些有有些没有，干脆直接删除在进行一次添加【刚好也能用到之前写的SQL语句
类似于插入，但是主键为刚写的**回显是包含id**的，【被删除的老的包含，但是新的不包含故还是需要进行遍历set】


### 3.6 先补全视频查看有无遗漏
牛魔既有单个删除，也有批量删除【这就是不看视频的代价

在修改以及回显中包含多表SQL使用，DishVO甚至包含3个表的内容
其中修改以及回显中都有运用分类表的**类型**查询表

修改口味表选择直接删除再次添加是因为其id并没有相关表的连接【比如分类就不能修改因为其有关联外键

###### 菜品管理，菜品起售停售功能：
类似于启用禁用员工账号【100%一样
大错特错
没有考虑到表和表之间的关系
有一个**中间表菜品套餐表**
`如果菜品与套餐有关联，套餐中的一个菜品进行了停售，那么这个套餐也要进行停售`

###### 修改密码：
要手动地进行当前员工 id 获取【因为使用员工id的地方少，切面类中只对新增以及修改进行了自动填充公共数据
通过 id 进行查询，
然后进行比对，
错误的进行抛出异常，
最后进行修改


###### 新增套餐：
类似于新增菜品【均为插入
其DTO下包含套餐表的修改，以及其连接表同菜品的关系
【同样要进行主键的返回】【但其同菜品的关系是必填的，故不需要进行判断

如何选取其菜品同套餐的关系呢？
【让套餐可通过 `分类表中菜品id` 查询 `对应菜品表中菜品` 选择其中菜品
【==**前置接口+1**==】
根据分类id查询菜品[要对菜品状态进行判断，**在售才可进行显示**【**菜品禁用时，套餐要禁用**


### 3.7 
牛魔，OOS对象密钥泄露，已经禁用【下次记得忽略
上午全在改这个,随便尝试解决德鲁伊报错将版本1.2.1改为1.2.2

目标任务：了解到了接口的更多关系，比如分类接口中的`根据类型查分类`可查询菜品以及套餐列表，也就是`菜品分类`与`套餐分类`【新增右上角】
一个小小的理解了一下

###### 套餐分页查询：
同菜品分页查询类似，有一个参数存在于`分类表`中叫做套餐类型，
需要你将两表进行左外连接进行查询，并且要起别名，让其产生自动映射【多表语句时最好，所有属性都要进行注明
【这个属性同菜品的分类名称一样，是在新建时选用的【使用的是分类表中的`通过类型查询分类`接口】】

###### 删除套餐：
通过业务原型右侧，可得知在售不能进行删除，同菜品删除一样【**需要通过id查询进行判断**
删除时需要删除两个表,
一个是套餐本表，
一个是中间表


### 3.8 写完day4的课后接口

###### 修改套餐
需要有前置
根据 id 查询套餐【回显】【包含回显需要两个表进行融合】
修改：同菜品修改一样，套餐表进行直接修改，套餐菜品表进行**批量删除，
以及批量插入**【新选中的菜品关系是独立的需要自行 set 对应`套餐id`】

###### 起售停售套餐
直接修改即可【在写菜品禁用时已经写好逻辑】
【上的禁用，不会影响到下的禁用】
但是其启用需要对其**连接表内进行查询**后对**菜品表查询全为启用**才可启用
1、【反转 `菜品删除` 中的查询中间表【单个查询怕返回集合 】
2、foreach 遍历进行菜品表的 id 查询进行状态判断【不行则抛出异常】
答案中是使用连接表的方式，确实帅

###### Redis!
学习Redis使用在java中
一、先导入依赖。
二、对其yaml中进行配置。port、host等数据
三、新建配置类加入Bean对象【主要目的：进行自定义的消息序列化】
四、配置的Bean对象进行调用Redis的各种语句进行操作

###### 新增店铺接口：
对营业状态进行查询和修改
【由于其分为用户端以及管理端，其用户端也需要进行查询故对用户端也复制一份】

同上原因，其分为两个端:生成接口文档需要两份对双端进行扫描
【复制代码修改扫描对象并且进行分组即可】



### 3.9 直接day6,开新内容了
byd直接看完了
学习HttpClient相关api，使用封装工具类
介绍微信小程序的开发，导入写好的代码——前端页面

书写C端-根据微信登录流程：
使用封装工具类请求微信获取openid
根据Openid查询用户，老用户则获取id，新用户则插入返回主键获取

新增JWT拦截器用户端：
新增拦截类，配置类中额外注册拦截对象

修正错误，用户创建时修正为用户获取

新增C端-浏览功能4个
`均需要前提-在售`

根据类型查询分类
根据分类 id 查询菜品
根据分类 id 查询套餐
根据套餐 id 查询包含的菜品


### 3.10 速度减缓
上午编写日志以及笔记

###### 缓存商品：
**均在Controller修改**【`对菜品进行`】

创建缓存：
用户端查询时进行判断，有缓存查缓存，没缓存查询后新建缓存

清理缓存：
管理端口进行增、删、改时进行清理缓存
增:直接对其进行修改对应分类id
删:参考全删除
改:参考全删除

####### Spring_Cache
了解Cache的使用并且补全
查询套餐的缓存
以及清理缓存
**全都使用注解**


### 3.11 继续购物车
###### 购物车：
添加购物车：
    先查询，判断表中有没有已存在对其分为存在+1，不存在进行插入。
    在补全信息时对其进行判断是菜品还是套餐进行获取`冗余字段`最后插入

查看购物车：
直接对其userid进行查询即可

清空购物车
直接对其userid进行删除即可

删除购物车中一个商品
先查询>1的话就-1，等于1就根据id进行删除

###### 导入单表的地址簿：
查询地址列表:通过userId进行条件查询地址【条件伏笔了手机查询以及地址查询

新增地址:普通的新增，加上userId进行标识以及默认是非默认地址

修改地址:先通过id查询进行回显，后通过id进行修改地址【动态SQL的修改

删除地址:通过id进行删除

设置默认地址:对userId进行修改默认地址为0，在对当前传入进行修改为1

查询默认地址:条件查询为地址为1的地址

对于默认地址也许可以改为用redis进行覆盖每次【每个userid只能有一个保存id

###### 用户下单：
`对接口的设计要进行分析`

真实的开发通常字段是非常多的， 
要对其有用的字段进行插入即可，多余字段在后续会进行使用
业务处理流程：
0、对购物车以及地址簿**进行校验**【通过id进行查询，为空则抛出异常
【此处要对字段进行清晰的认知**并结合实际**】

1、对订单表进行插入一条【要分清能获取数据进行插入【**数据不全，可以插入，为空也能进行插入**】

2 、为订单明细表插入n条【订单明细表类似于购物车表，其多了订单id【屁话！少了userId{**没主键无法存入**}，以及创建时间

3、清空购物车

4、返回封装的vo视图对象【通过订单表中数据进行获取即可


### 3.12 微信支付 3.12 3.13 day9课后作业
无法跟进实践的东西：需要相关证明
相关操作等于，HttpClient的进阶
使用此格式编写

[开发指引-小程序支付 | 微信支付商户平台文档中心 (qq.com)](https://pay.weixin.qq.com/wiki/doc/apiv3/open/pay/chapter2_8_2.shtml)

得到

https://pay.weixin.qq.com/docs/merchant/apis/jsapi-payment/direct-jsons/jsapi-prepay.html
https://pay.weixin.qq.com/docs/merchant/apis/mini-program-payment/mini-transfer-payment.html
https://pay.weixin.qq.com/wiki/doc/apiv3/apis/chapter3_5_5.shtml

也就是后端请求微信进行预支付编码给小程序端
小程序端口再调用微信API进行支付，微信进行回调提醒最终结果
后端响应给微信API告知收到

既然我们无法对其进行使用，并要**将代码进行修改**
TODO

###项目实战补全订单代码[双端]
用户端历史订单模块：

- 查询历史订单
  - 开了眼了!——分页查询还能分成两个查询,并且vo视图对象使用了继承
- 查询订单详情
  - 就是普通的查询订单涉及到两个表，将其进行合并
- 取消订单[包含退款]
  - 正常的逻辑进行分析业务流程，只有状态为1，2时进行取消订单，其余需要`打电话`就是拒绝并抛出异常
  - `订单状态的退款`同`支付状态的退款`并非一个退款，故无需修改X,
  - 订单状态的状态7已退款,应该是被放弃改为6已取消,**此处修改了支付状态为已退款**
- 再来一单
  - 了解需求，`将订单明细放入购物车即可`，取消id复制补充userId，创建时间

商家端订单管理模块：

- 订单搜索
  - 类似与用户端的分页条件查询【2个查询】，但是其2表属性并非为菜品List，而是过滤后的String【VO对象所有属性都进行了使用
  - 使用Stream流进行过滤收集成字符串数组【**复习**】，使用String.join将集合进行拼接为整个String返回VO
- 各个状态的订单数量统计
  - 就是简单的统计而已，可以写个SQL进行查询
- 查询订单详情
  - 用户端已写【给个请求路径即可】
- 接单
  - 如果参数为单个Long 值时不能使用@RequestBody，**否则会发生序列化异常**【未知原因】，此处将其修改为给定的DTO类，**第二个属性传入为空**、修改订单状态
  - 【关于订单状态的变化需要由规定方向变化，不能破坏路线】
- 拒单[包含退款]
  - 使用支付状态进行判断是否要进行退款？【由于微信支付无法通过，其状态无法改变此此处退款不会触发】
  - 参考标准中不同于用户端，**此处并没有修改支付状态**,并且返回输出了一个日志,补全拒单字段、修改订单状态
  - 【关于订单状态的变化需要由规定方向变化，不能破坏路线】
- 取消订单[包含退款]
  - 使用支付状态进行判断是否要进行退款？【由于微信支付无法通过，其状态无法改变此此处退款不会触发】
  - **此处同样没有修改支付状态**,并且返回输出了一个日志,补全取消订单字段、修改订单状态
  - 【关于订单状态的变化需要由规定方向变化，不能破坏路线】
- 派送订单
  - 修改订单状态
  - 【关于订单状态的变化需要由规定方向变化，不能破坏路线】
- 完成订单
  - 修改订单状态
  - 【关于订单状态的变化需要由规定方向变化，不能破坏路线】



### 3.14 
补全日志笔记以及百度API
1、配置文件，地址，AK
2、去查找相关API

[地理编码 | 百度地图API SDK (baidu.com)](https://lbsyun.baidu.com/faq/api?title=webapi/guide/webservice-geocoding-base)

[轻量级路线规划 | 百度地图API SDK (baidu.com)](https://lbs.baidu.com/faq/api?title=webapi/guide/webservice-lwrouteplanapi/dirve)

以上 api 的使用不同于微信支付般复杂，只需要传入对应值即可直接进行使用

之后，对其返回**JSON文件进行解析**，即可得到相应数据
【需要对JSON文件的解析进行补全知识【`除了半吊子的微信根本没见过啥解析`】】


完毕以上订单模块进行修改下单支付

参考
[解决苍穹外卖支付问题-CSDN博客](https://blog.csdn.net/Keyboard_01/article/details/134736416?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-134736416-blog-134769838.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-134736416-blog-134769838.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=1)

[苍穹外卖——跳过微信支付-CSDN博客](https://blog.csdn.net/apple_51927114/article/details/134769838?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-134769838-blog-132677932.235%5Ev43%5Epc_blog_bottom_relevance_base6&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-134769838-blog-132677932.235%5Ev43%5Epc_blog_bottom_relevance_base6&utm_relevant_index=1)
总而言之就是
1、修改前端：无需进行程序的直接调用微信支付方法

2、修改后端：`订单支付`时直接调用**回调运用的支付成功修改方法**

3、除了订单支付接口有3个地方调用了微信支付，分别是：用户端取消订单、管理端取消订单，管理端拒绝订单【都注释即可】

### 3.15 
总结json解析
编写笔记

###### Spring_Task定时任务框架：
引入依赖：被 springboot 的起步依赖所依赖传递

在启动类中添加注解@EnableScheduling 开启任务调度

编写任务类，需要将任务类加入第三方，方法命名没有要求，但需要在其之上添加注解
`@Scheduled(cron = "0/5 * * * * ?")` 内部是`Cron表达式`类似于Cache的 spel 语法

使用目的：
用户下单后可能存在的情况：
- 下单后未支付，订单一直处于**待支付**状态
- 用户收货后管理端未点击完成按钮，订单一直处于**派送中**状态

过程：
- 编写新SQL，通过对状态以及订单创建的时间进行搜寻 
  - 其中创建时间＜【第一次使用非精确SQL】，使用 localdata 进行时间加减
- 查询值进行非空判断，补充取消所需参数，最后进行修改状态


###### WebSocket
是一种协议，底层是TCP
适用场景:网页不刷新，但是有新的数据进行展示

区别于 http 协议

**在视频中讲解的并非很细致，其大部分所需代码都进行导入**

步骤:
- 1、前端页面实现请求握手
- 2、引入依赖
- 3、根据请求握手去编写类似 controller 的服务类
- 4、编写配置类注册3编写的服务类
- 5、模拟使用【双向信息传递

来单提醒、客户催单：
由于 引入了依赖
并且后端的网页前端中也编写了相应代码
并且写好了服务类以及注册了服务类

此处只需要**将约定的 JSON 格式进行封装**<mark style="background: #FF5582A6;">使用服务类中方法进行请求</mark>即可

来单提醒：
其用在用户下单完后，微信支付完毕，通过微信的回调对订单表进行修改时进行提醒
**故需要修改 paySuccess 方法，加入 websocket发送请求**

客户催单：
通过用户端接口进行调用 websocket 的方法发送请求
为了健全性，添加一个订单判断以及**只有待接单才能催单**


### 3.16 数据统计
以下接口，其Mapping传参均用map进行封装，我没有使用同样方法，**后续工作台接口导入时需要进行更改**
并且都是对 SQL 的使用，第一次真正用到><,之前订单分页查询，参数不够，写的只是空架子

###### 营业额统计:
分为3个步骤
1、补全传入参数之间的天数
  【时间类的使用：新建集合，起始进行加一，与结束进行比较，加入集合

2、遍历天数集合，其中根据范围编写SQL查询营业额【使用集合收集所需值】
  【需要将传入参数localdata类更改为localDataTime
  【此处SQL可对其进行SUM累加，而并非查询对象类后再进行遍历累加【需要添加一个为空判断，防止查询不到为null报错
    【避免了返回对象，{**再进行一次遍历**}其中金额使用为 BigDecimal不好操作【也可以使用，Stream流进行操作】

3、构造封装 vo 对象【拼接使用了**工具类**StringUtils.join(),
  不同于String.join(),无需将集合内容转换为字符串,内部自动帮你转换

###### 用户统计:
同上步骤，
先获取之间的时间，遍历集合
将类修改为 localDataTime，使用SQL语句获取所需值【使用集合收集】
封装 vo 对象


###### 订单统计:
同上步骤，
先获取之间的时间，遍历集合
将类修改为 localDataTime，使用SQL语句获取所需值【使用集合收集】
`【此处需要遍历收集到的集合进行加和，使用Stream流的reduce进行sum简化流程】`
【正常的除数判断0异常】
封装 vo 对象


###### 销量排名Top10:
内容差不多
但是 SQL 语句偏于复杂
  传入值依旧为 localdata需要转换
  销量肯定是要有效订单【将订单明细表与订单表连接
  响应值为名称name与个数number，并且进行排序，又要比较数量【有订单以及菜品【不能使用两个进行分组】
    故使用到**使用名字name分组**

以上 sql 语句查询返回值为封装类的集合
又使用了一波高级流，集合转化为流使用其封装类自带的方法以及map方法，
  将其流内部类型转换为name名字的String，使用收集方法将其转化为集合，使用工具类将其拼接
`封装类内部两个都是如此操作`【太帅了！】
最后，封装 VO 响应返回


###### 导入工作台代码 包含了4个接口
【一共有6个两个在订单中已完成
以上说明了写的数据统计接口中参数没有用，map进行封装，需要进行小修改
**【在修改中，你就能知道为什么要使用 map 进行封装，可以使其更加便捷的修改内部数据】**

- 今日数据接口
  - 大量的 mapping 接口使用获取对应值进行返回【类似于上面的数据统计接口】
    * 营业额：当日已完成订单的总金额
    * 有效订单：当日已完成订单的数量
    * 订单完成率：有效订单数 / 总订单数
    * 平均客单价：营业额 / 有效订单数
    * 新增用户：当日新增用户的数量
- 订单管理接口{今日}
  - 【最能感受到 map 封装的使用，大量使用订单统计接口】

- 菜品总览接口、套餐总览接口【兄弟接口】
  - 简单的进行禁用和非禁用的查询【同样使用 map 进行封装】
  


### 3.17 POI day12终结————看30集前端
###### 导入 Excel 报表——————前置技术阿帕奇POI